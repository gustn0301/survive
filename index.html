<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Surviv.io Clone - Final Polish</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            cursor: crosshair;
        }

        /* UI Layers */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }

        /* Stats & HUD */
        #health-container {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 25px; background: rgba(0, 0, 0, 0.5);
            border-radius: 12px; border: 2px solid #333; overflow: hidden;
        }
        #health-bar { width: 100%; height: 100%; background-color: #2ecc71; transition: width 0.1s linear; }

        #gear-container {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px;
        }
        .gear-icon {
            width: 20px; height: 20px; background: rgba(0,0,0,0.5);
            border: 1px solid #555; border-radius: 4px; color: white;
            font-size: 10px; display: flex; justify-content: center; align-items: center; font-weight: bold;
        }
        .gear-lvl-1 { background: #95a5a6; border-color: #7f8c8d; }
        .gear-lvl-2 { background: #f1c40f; border-color: #f39c12; color: black; }
        .gear-lvl-3 { background: #2c3e50; border-color: #000; }
        /* Ghillie Icon Green */
        .gear-ghillie { background: #78ab46; border-color: #5d8c32; color: white; text-shadow: 1px 1px 0 #000; }

        #inventory-ui {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px;
        }
        .inv-slot {
            width: 60px; height: 60px; background: rgba(0,0,0,0.6);
            border: 2px solid #444; border-radius: 8px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #aaa; font-size: 12px; position: relative;
        }
        .inv-slot.active { border-color: #f1c40f; background: rgba(241, 196, 15, 0.1); transform: scale(1.1); }
        .slot-key { position: absolute; top: 2px; left: 5px; font-size: 10px; color: #fff; font-weight: bold; }
        .slot-name { font-weight: bold; color: white; text-align: center; font-size: 10px; }
        .slot-ammo { color: #f1c40f; font-size: 14px; font-weight: bold; margin-top: 2px; }

        #scope-display {
            position: absolute; bottom: 180px; right: 20px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 50%;
            width: 40px; height: 40px; display: flex; justify-content: center; align-items: center;
            color: white; font-weight: bold; border: 2px solid #fff;
        }

        #ammo-pouch {
            position: absolute; bottom: 20px; right: 20px;
            text-align: right; color: white; font-size: 12px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px;
        }
        .ammo-row { display: flex; justify-content: flex-end; gap: 10px; margin-bottom: 2px;}

        #game-message {
            position: absolute; top: 100px; left: 50%; transform: translateX(-50%);
            color: white; font-size: 24px; font-weight: bold;
            text-shadow: 2px 2px 0 #000; background: rgba(0,0,0,0.6); padding: 10px 30px; border-radius: 25px;
            opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }

        #cast-bar-container {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 10px; background: rgba(0,0,0,0.6); border-radius: 5px; display: none;
        }
        #cast-bar { width: 0%; height: 100%; background-color: #3498db; }

        #kill-feed { position: absolute; top: 20px; left: 20px; color: white; font-size: 14px; text-shadow: 1px 1px 0 #000; }
        #zone-warning {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            color: #e74c3c; font-size: 24px; font-weight: bold; text-shadow: 2px 2px 0 #000;
            opacity: 0; transition: opacity 0.5s;
        }

        /* Screens */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white;
            pointer-events: auto; z-index: 100;
        }
        .hidden { display: none !important; }
        h1 { font-size: 50px; margin-bottom: 20px; color: #f1c40f; text-shadow: 4px 4px 0 #000; text-align: center; }
        p { font-size: 16px; color: #ccc; margin-bottom: 40px; text-align: center; }
        .btn {
            background: #2ecc71; color: white; border: none; padding: 15px 40px;
            font-size: 24px; font-weight: bold; border-radius: 8px; cursor: pointer;
            box-shadow: 0 5px 0 #27ae60; transition: transform 0.1s;
        }
        .btn:active { transform: translateY(5px); box-shadow: none; }
        .btn:disabled { background: #555; box-shadow: none; cursor: not-allowed; }

        /* Winner Animation */
        #winner-container {
            display: flex; flex-direction: column; align-items: center;
            font-size: 60px; font-weight: 900; color: #f1c40f;
            text-shadow: 4px 4px 0 #000; text-transform: uppercase;
            margin-bottom: 20px;
        }
        .win-word {
            opacity: 0; transform: scale(0.5);
            animation: popIn 0.5s forwards cubic-bezier(0.175, 0.885, 0.32, 1.275);
            margin: 5px 0;
        }
        @keyframes popIn {
            to { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="game-message">WAITING FOR PLAYER 2...</div>
        <div id="kill-feed"></div>
        <div id="zone-warning">THE ZONE IS SHRINKING!</div>
        <div id="scope-display">1x</div>
        
        <div id="ammo-pouch">
            <div class="ammo-row" style="color:#2ecc71">5.56: <span id="ammo-556">0</span></div>
            <div class="ammo-row" style="color:#3498db">7.62: <span id="ammo-762">0</span></div>
            <div class="ammo-row" style="color:#f1c40f">9mm: <span id="ammo-9mm">0</span></div>
            <div class="ammo-row" style="color:#e74c3c">12g: <span id="ammo-12g">0</span></div>
            <div class="ammo-row" style="color:#fff;">Meds: <span id="count-meds">0</span></div>
        </div>

        <div id="cast-bar-container"><div id="cast-bar"></div></div>

        <div id="inventory-ui">
            <div id="slot-1" class="inv-slot"><span class="slot-key">1</span><span class="slot-name">Empty</span><span class="slot-ammo"></span></div>
            <div id="slot-2" class="inv-slot"><span class="slot-key">2</span><span class="slot-name">Empty</span><span class="slot-ammo"></span></div>
            <div id="slot-3" class="inv-slot active"><span class="slot-key">3</span><span class="slot-name">Fists</span><span class="slot-ammo">âˆž</span></div>
        </div>
        
        <div id="gear-container">
            <div id="gear-vest" class="gear-icon">V</div>
            <div id="gear-bag" class="gear-icon">B</div>
            <div id="gear-ghillie" class="gear-icon hidden">G</div>
        </div>

        <div id="health-container"><div id="health-bar"></div></div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen">
        <h1>Surviv.io 1vs1</h1>
        <p><b>Instant Action:</b> First player hosts, Second player joins.<br>Airdrop at 30s (Groza/AWM/Ghillie)<br>Controls: WASD, R, F, 0(Heal)</p>
        <button id="find-match-btn" class="btn">ENTER BATTLE</button>
        <p id="match-status" style="margin-top: 20px; color: #f1c40f;"></p>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden">
        <div id="winner-container"></div>
        <h1 id="go-title" style="font-size: 30px; color: #e74c3c;"></h1>
        <button class="btn" onclick="location.reload()" style="margin-top: 20px;">MAIN MENU</button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, updateDoc, doc, query, where, getDocs, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAbCUFaHHbgWYrHY327Jfq3YUkrJ7eR2d8",
            authDomain: "surviv-io-4dd46.firebaseapp.com",
            projectId: "surviv-io-4dd46",
            storageBucket: "surviv-io-4dd46.firebasestorage.app",
            messagingSenderId: "868516100330",
            appId: "1:868516100330:web:a4ebdd5bb00e0627a33f93"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        const APP_ID_PATH = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const GAMES_COLLECTION = `artifacts/${APP_ID_PATH}/public/data/games`;

        let currentUser = null;
        let currentGameId = null;
        let isHost = false;
        let mapSeed = 12345;

        function seededRandom() {
            let x = Math.sin(mapSeed++) * 10000;
            return x - Math.floor(x);
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Game Globals
        let gameState = 'MENU';
        let lastTime = 0;
        let gameTime = 0;
        let cameraZoom = 1.0;
        const MAP_SIZE = 5000; 
        const TILE_SIZE = 100;
        const MINIMAP_SIZE = 140;

        let player = null;
        let opponent = null;
        let bullets = [];
        let obstacles = [];
        let walls = [];
        let roofs = [];
        let floors = [];
        let loot = [];
        let particles = [];
        let screenShake = 0;
        let airdropDropped = false;

        const ZONE_PHASES = [
            { t: 0, r: MAP_SIZE, dmg: 0 },
            { t: 0, r: MAP_SIZE * 0.8, dmg: 1 },    
            { t: 60, r: MAP_SIZE * 0.6, dmg: 2 },   
            { t: 150, r: MAP_SIZE * 0.4, dmg: 5 },  
            { t: 240, r: 0, dmg: 20 }               
        ];
        let zone = { x: MAP_SIZE/2, y: MAP_SIZE/2, radius: MAP_SIZE, phaseIdx: 1, damage: 1, damageTick: 0 };

        const COLORS = {
            playerBody: '#f1c40f', opponentBody: '#e74c3c', playerHand: '#333',
            crate: '#8e44ad', chest: '#f1c40f', airdrop: '#e74c3c',
            tree: '#2ecc71', stone: '#95a5a6', bush: 'rgba(46, 204, 113, 0.9)',
            ground: '#78ab46', // Ground Color
            floorClub: '#922b21', floorHouse: '#d5d8dc',
            wall: '#2c3e50', roof: '#34495e', grid: 'rgba(0,0,0,0.1)',
            pack1: '#95a5a6', pack2: '#3498db', pack3: '#2c3e50',
            vest1: '#95a5a6', vest2: '#2c3e50', vest3: '#000000',
            ghillie: '#78ab46' // Matches ground EXACTLY
        };

        const WEAPONS = {
            fist: { name: 'Fists', ammoType: 'none', damage: 15, fireRate: 400, spread: 0.2, speed: 20, range: 60, capacity: Infinity, reloadTime: 0, auto: true, color: 'transparent', count: 1 },
            pistol: { name: 'M9', ammoType: '9mm', damage: 12, fireRate: 350, spread: 0.08, speed: 25, range: 600, capacity: 15, reloadTime: 1000, auto: false, color: '#f1c40f', count: 1 },
            ak: { name: 'AK-47', ammoType: '762mm', damage: 16, fireRate: 110, spread: 0.12, speed: 28, range: 900, capacity: 30, reloadTime: 2200, auto: true, color: '#3498db', count: 1 },
            shotgun: { name: 'M870', ammoType: '12gauge', damage: 10, fireRate: 900, spread: 0.35, speed: 22, range: 450, capacity: 5, reloadTime: 2800, auto: false, color: '#e74c3c', count: 6 },
            smg: { name: 'UZI', ammoType: '9mm', damage: 9, fireRate: 60, spread: 0.25, speed: 24, range: 500, capacity: 32, reloadTime: 1800, auto: true, color: '#f1c40f', count: 1 },
            kar98k: { name: 'Kar98k', ammoType: '762mm', damage: 75, fireRate: 1500, spread: 0.02, speed: 45, range: 2000, capacity: 5, reloadTime: 3000, auto: false, color: '#3498db', count: 1 },
            m249: { name: 'M249', ammoType: '556mm', damage: 14, fireRate: 70, spread: 0.15, speed: 28, range: 1000, capacity: 100, reloadTime: 4000, auto: true, color: '#2ecc71', count: 1 },
            groza: { name: 'Groza', ammoType: '762mm', damage: 20, fireRate: 80, spread: 0.1, speed: 30, range: 900, capacity: 30, reloadTime: 2000, auto: true, color: '#3498db', count: 1 },
            awm: { name: 'AWM-S', ammoType: '308sub', damage: 180, fireRate: 1800, spread: 0.005, speed: 60, range: 2500, capacity: 5, reloadTime: 3500, auto: false, color: '#1abc9c', count: 1 }
        };

        const AMMO_TYPES = { '556mm': '#2ecc71', '762mm': '#3498db', '9mm': '#f1c40f', '12gauge': '#e74c3c', '308sub': '#1abc9c', 'none': 'transparent' };

        // --- Inputs ---
        const keys = {};
        const mouse = { x: 0, y: 0, down: false, worldX: 0, worldY: 0 };
        
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (!player || gameState !== 'PLAYING') return;
            if(e.key === '1') player.switchSlot(0);
            if(e.key === '2') player.switchSlot(1);
            if(e.key === '3') player.switchSlot(2);
            if(e.key === '0') player.startHealing();
        });
        window.addEventListener('keyup', e => {
            keys[e.code] = false;
            if (!player || gameState !== 'PLAYING') return;
            if(e.code === 'KeyR') player.reload();
            if(e.code === 'KeyF') interact();
        });
        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('mousedown', () => mouse.down = true);
        window.addEventListener('mouseup', () => mouse.down = false);

        // --- Matchmaking ---
        const btn = document.getElementById('find-match-btn');
        const statusTxt = document.getElementById('match-status');

        auth.onAuthStateChanged((user) => {
            if (user) { currentUser = user; btn.disabled = false; } 
            else { signInAnonymously(auth); }
        });

        btn.addEventListener('click', async () => {
            if (!currentUser) return;
            btn.disabled = true;
            statusTxt.innerText = "Checking for games...";

            try {
                const q = query(collection(db, GAMES_COLLECTION), where("status", "==", "waiting"));
                const querySnapshot = await getDocs(q);
                let foundGame = null;

                querySnapshot.forEach((doc) => {
                    if (doc.data().hostId !== currentUser.uid) foundGame = doc;
                });

                if (foundGame) {
                    currentGameId = foundGame.id;
                    isHost = false;
                    mapSeed = foundGame.data().seed || 12345;
                    statusTxt.innerText = "Game found! Entering...";
                    await updateDoc(doc(db, GAMES_COLLECTION, currentGameId), { guestId: currentUser.uid, status: 'active' });
                    startGame(false);
                } else {
                    statusTxt.innerText = "No games found. Hosting new game...";
                    isHost = true;
                    mapSeed = Math.floor(Math.random() * 100000);
                    const docRef = await addDoc(collection(db, GAMES_COLLECTION), {
                        hostId: currentUser.uid, guestId: null, status: 'waiting', seed: mapSeed, createdAt: Date.now()
                    });
                    currentGameId = docRef.id;
                    startGame(true);
                    listenForGuest();
                }
            } catch (e) {
                console.error("Match error:", e);
                statusTxt.innerText = "Error: " + e.message;
                btn.disabled = false;
            }
        });

        function listenForGuest() {
            const unsub = onSnapshot(doc(db, GAMES_COLLECTION, currentGameId), (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    if (data.status === 'active' && data.guestId) {
                        showGameMessage("PLAYER 2 CONNECTED!");
                        unsub();
                    }
                }
            });
        }

        function showGameMessage(msg) {
            const el = document.getElementById('game-message');
            el.innerText = msg; el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 4000);
        }

        function startGame(isHosting) {
            document.getElementById('start-screen').classList.add('hidden');
            if (isHosting) showGameMessage("HOSTING: WAITING FOR P2...");
            else showGameMessage("CONNECTED TO HOST!");

            initGame(mapSeed);
            gameState = 'PLAYING';
            lastTime = performance.now(); 
            startSync();
            startLootSync(); 
            requestAnimationFrame(loop);
        }

        let lastSyncTime = 0;
        function startSync() {
            setInterval(async () => {
                if (gameState !== 'PLAYING' || !player || !currentGameId) return;
                const now = Date.now();
                if (now - lastSyncTime < 80) return; 
                lastSyncTime = now;

                const playerData = {
                    x: Math.round(player.x), y: Math.round(player.y),
                    angle: parseFloat(player.angle.toFixed(2)),
                    hp: Math.round(player.hp),
                    wep: player.getActiveWeapon().type,
                    vest: player.vestLevel, pack: player.backpackLevel,
                    ghillie: player.isGhillie,
                    shoot: player.lastShotTime,
                    dead: player.dead
                };
                try { setDoc(doc(db, `${GAMES_COLLECTION}/${currentGameId}/players`, currentUser.uid), playerData); } catch(e) {}
            }, 100);

            onSnapshot(collection(db, `${GAMES_COLLECTION}/${currentGameId}/players`), (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === "added" || change.type === "modified") {
                        const pid = change.doc.id;
                        const data = change.doc.data();
                        if (pid !== currentUser.uid && opponent) {
                            opponent.connected = true; 
                            opponent.targetX = data.x; opponent.targetY = data.y;
                            opponent.targetAngle = data.angle; opponent.hp = data.hp;
                            opponent.vestLevel = data.vest || 0; opponent.backpackLevel = data.pack || 0;
                            opponent.isGhillie = data.ghillie || false;
                            
                            if (data.dead && !opponent.dead) {
                                opponent.dead = true;
                                endGame(true); // I win!
                            }

                            if (data.shoot > opponent.lastShotTime) {
                                opponent.lastShotTime = data.shoot;
                                opponent.activeWeapon = data.wep;
                                opponent.triggerShoot(data.wep);
                            }
                        }
                    }
                });
            });
        }

        function startLootSync() {
            onSnapshot(collection(db, `${GAMES_COLLECTION}/${currentGameId}/takenLoot`), (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === "added") {
                        const takenId = change.doc.id;
                        loot = loot.filter(l => l.id !== takenId);
                    }
                });
            });
        }

        function takeLoot(item) {
            loot = loot.filter(l => l.id !== item.id);
            try {
                setDoc(doc(db, `${GAMES_COLLECTION}/${currentGameId}/takenLoot`, item.id), {
                    takenBy: currentUser.uid, at: Date.now()
                });
            } catch(e) {}
        }

        // --- Deterministic Loot Helper ---
        // We use mapSeed + x + y to generate a consistent random item for each crate
        function determineLootItem(x, y, isChest = false, isAirdrop = false) {
            // Pseudo-random based on position & seed
            let val = Math.sin(mapSeed + x * 0.01 + y * 0.02) * 10000;
            let r = val - Math.floor(val); // 0.0 to 1.0

            if (isChest) {
                return 'm249'; // Chest always M249
            }
            if (isAirdrop) {
                if(r < 0.33) return 'awm';
                else if(r < 0.66) return 'groza';
                else return 'm249';
            }
            // Normal Crate
            // High chance for medkit as requested
            if (r < 0.4) return 'medkit'; 
            else if (r < 0.5) return 'vest1';
            else if (r < 0.6) return 'pack1';
            else if (r < 0.75) return 'pistol';
            else if (r < 0.85) return 'smg';
            else if (r < 0.92) return 'shotgun';
            else if (r < 0.96) return 'ak';
            else return 'kar98k';
        }

        // --- Classes ---

        class Entity {
            constructor(x, y, radius) { this.x=x; this.y=y; this.radius=radius; this.dead=false; }
            dist(other) { return Math.hypot(this.x - other.x, this.y - other.y); }
        }

        class Player extends Entity {
            constructor(x, y, isRemote = false) {
                super(x, y, 25);
                this.isRemote = isRemote;
                this.connected = !isRemote;
                this.hp = 100; this.maxHp = 100;
                this.speed = 300; 
                this.angle = 0;
                
                this.inventoryState = [null, null, { type: 'fist', ammo: Infinity, mag: Infinity }];
                this.activeSlot = 2; 
                this.ammoBag = { '556mm': 0, '762mm': 0, '9mm': 0, '12gauge': 0, '308sub': 0 };
                this.medkits = 0;
                this.vestLevel = 0; this.backpackLevel = 0;
                this.scopeLevel = 1;
                this.isGhillie = false;

                this.targetX = x; this.targetY = y; this.targetAngle = 0;
                this.activeWeapon = 'fist';

                this.reloading = false; this.reloadEndTime = 0; this.lastShotTime = 0;
                this.isHealing = false; this.healStartTime = 0; this.healDuration = 3000;
                this.inBush = false;
            }

            getActiveWeapon() { 
                if (this.isRemote) return { type: this.activeWeapon || 'fist' };
                return this.inventoryState[this.activeSlot]; 
            }
            getWeaponStats() { return WEAPONS[this.getActiveWeapon().type] || WEAPONS['fist']; }
            getMaxAmmo(type) {
                let caps = { '556mm': 120, '762mm': 120, '9mm': 180, '12gauge': 30, '308sub': 20 };
                let mult = 1.0;
                if (this.backpackLevel === 1) mult = 1.5; if (this.backpackLevel === 2) mult = 2.0; if (this.backpackLevel === 3) mult = 3.0;
                return Math.floor(caps[type] * mult);
            }

            triggerShoot(wepType) {
                const stats = WEAPONS[wepType];
                const shotCount = stats.count || 1;
                for(let i=0; i<shotCount; i++) {
                    let spread = stats.spread;
                    let angle = this.angle + (Math.random() - 0.5) * spread;
                    bullets.push(new Bullet(this.x + Math.cos(this.angle)*30, this.y + Math.sin(this.angle)*30, angle, this, stats));
                }
            }

            updateRemote(dt) {
                if (!this.connected) return;
                this.x += (this.targetX - this.x) * 5 * dt;
                this.y += (this.targetY - this.y) * 5 * dt;
                let da = (this.targetAngle - this.angle);
                while (da > Math.PI) da -= Math.PI * 2;
                while (da < -Math.PI) da += Math.PI * 2;
                this.angle += da * 5 * dt;
                // Dead state is synced via Snapshot, no logic here needed
            }

            switchSlot(idx) {
                if (idx < 0 || idx > 2) return;
                if (this.inventoryState[idx] === null) return; 
                this.cancelAction(); this.activeSlot = idx; updateUI();
            }

            startHealing() {
                if (this.hp >= 100 || this.medkits <= 0 || this.isHealing) return;
                this.cancelAction(); this.isHealing = true; this.healStartTime = Date.now();
                document.getElementById('cast-bar-container').style.display = 'block';
            }

            cancelAction() {
                this.reloading = false; this.isHealing = false;
                document.getElementById('cast-bar-container').style.display = 'none';
            }

            updateHealing() {
                if (!this.isHealing) return;
                let elapsed = Date.now() - this.healStartTime;
                let progress = elapsed / this.healDuration;
                document.getElementById('cast-bar').style.width = (progress * 100) + '%';
                if (elapsed >= this.healDuration) {
                    this.hp = Math.min(100, this.hp + 25); this.medkits--; this.isHealing = false;
                    document.getElementById('cast-bar-container').style.display = 'none';
                    particles.push(new TextParticle(this.x, this.y - 30, "+25 HP", "#2ecc71"));
                    updateUI();
                }
            }

            equipWeapon(type) {
                if (type.startsWith('scope')) {
                    let newLevel = parseInt(type.replace('scope', '').replace('x', ''));
                    if (this.scopeLevel > 1) loot.push(new Loot(this.x, this.y, 'scope' + this.scopeLevel + 'x'));
                    this.scopeLevel = newLevel;
                    particles.push(new TextParticle(this.x, this.y - 40, `${newLevel}x Equipped`, "#3498db"));
                    updateUI(); return;
                }
                if (type.startsWith('vest')) {
                    let lvl = parseInt(type.replace('vest', ''));
                    if (lvl > this.vestLevel) { this.vestLevel = lvl; particles.push(new TextParticle(this.x, this.y - 40, `Lvl ${lvl} Vest`, "#2c3e50")); updateUI(); }
                    return;
                }
                if (type.startsWith('pack')) {
                    let lvl = parseInt(type.replace('pack', ''));
                    if (lvl > this.backpackLevel) { this.backpackLevel = lvl; particles.push(new TextParticle(this.x, this.y - 40, `Lvl ${lvl} Bag`, "#3498db")); updateUI(); }
                    return;
                }
                if (type === 'ghillie') {
                    this.isGhillie = true;
                    particles.push(new TextParticle(this.x, this.y - 40, "Ghillie Suit", "#78ab46"));
                    updateUI(); return;
                }

                const stats = WEAPONS[type];
                if(stats.ammoType !== 'none') {
                    let max = this.getMaxAmmo(stats.ammoType);
                    let current = this.ammoBag[stats.ammoType];
                    this.ammoBag[stats.ammoType] = Math.min(max, current + 60);
                }
                const newWep = { type: type, mag: stats.capacity };
                if (this.activeSlot === 2) {
                    if (this.inventoryState[0] === null) { this.inventoryState[0] = newWep; this.switchSlot(0); }
                    else if (this.inventoryState[1] === null) { this.inventoryState[1] = newWep; this.switchSlot(1); }
                    else {
                        let old = this.inventoryState[0]; loot.push(new Loot(this.x, this.y, old.type));
                        this.inventoryState[0] = newWep; this.switchSlot(0);
                    }
                } else {
                    let old = this.inventoryState[this.activeSlot]; loot.push(new Loot(this.x, this.y, old.type));
                    this.inventoryState[this.activeSlot] = newWep;
                }
                updateUI();
            }

            update(dt) {
                if (this.dead) return;
                if (this.isRemote) { this.updateRemote(dt); return; }

                this.isUnderRoof = false;
                for(let r of roofs) { if (this.x > r.x && this.x < r.x + r.w && this.y > r.y && this.y < r.y + r.h) { this.isUnderRoof = true; break; } }

                if (this.reloading) { if (Date.now() > this.reloadEndTime) this.finishReload(); }
                this.updateHealing();

                let dx = 0, dy = 0;
                if (keys['KeyW']) dy -= 1; if (keys['KeyS']) dy += 1;
                if (keys['KeyA']) dx -= 1; if (keys['KeyD']) dx += 1;
                if (dx!==0 || dy!==0) {
                    let len = Math.hypot(dx,dy);
                    let moveAmt = this.speed * dt;
                    this.x += (dx/len) * moveAmt; 
                    this.y += (dy/len) * moveAmt;
                    if(this.isHealing) this.cancelAction();
                }
                this.angle = Math.atan2(mouse.worldY - this.y, mouse.worldX - this.x);

                const stats = this.getWeaponStats();
                if (mouse.down && !this.reloading && !this.isHealing) { if (stats.auto || !this.clicked) this.shoot(); }
                if (!mouse.down) this.clicked = false; else this.clicked = true;

                let wallHit = false;
                for (let wall of walls) { if (circleRectCollide(this, wall)) { wallHit = true; break; } }
                if(wallHit) { 
                    if (dx!==0 || dy!==0) {
                        let len = Math.hypot(dx,dy);
                        let moveAmt = this.speed * dt;
                        this.x -= (dx/len) * moveAmt; 
                        this.y -= (dy/len) * moveAmt;
                    }
                }

                this.x = Math.max(this.radius, Math.min(MAP_SIZE - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(MAP_SIZE - this.radius, this.y));

                let distToCenter = Math.hypot(this.x - zone.x, this.y - zone.y);
                if (distToCenter > zone.radius) {
                    if (gameTime > zone.damageTick) { this.takeDamage(zone.damage); zone.damageTick = gameTime + 1000; }
                }
            }

            shoot() {
                const wep = this.getActiveWeapon(); const stats = WEAPONS[wep.type];
                if (wep.type === 'fist') {
                     const now = Date.now();
                     if (now - this.lastShotTime >= stats.fireRate) {
                         this.lastShotTime = now;
                         bullets.push(new Bullet(this.x + Math.cos(this.angle)*30, this.y + Math.sin(this.angle)*30, this.angle, this, stats));
                     }
                     return;
                }
                if (wep.mag <= 0) { if (!this.reloading) this.reload(); return; }
                const now = Date.now();
                if (now - this.lastShotTime >= stats.fireRate) {
                    this.lastShotTime = now; wep.mag--; updateUI();
                    if(this.isHealing) this.cancelAction();
                    screenShake = 4;
                    const shotCount = stats.count || 1;
                    for(let i=0; i<shotCount; i++) {
                        let spread = stats.spread; let angle = this.angle + (Math.random() - 0.5) * spread;
                        bullets.push(new Bullet(this.x + Math.cos(this.angle)*30, this.y + Math.sin(this.angle)*30, angle, this, stats));
                    }
                }
            }

            reload() {
                const w = this.getActiveWeapon(); const stats = WEAPONS[w.type];
                if (w.type === 'fist' || this.reloading || this.isHealing) return;
                if (w.mag === stats.capacity) return;
                const reserve = this.ammoBag[stats.ammoType];
                if (reserve <= 0) { particles.push(new TextParticle(this.x, this.y-40, "No Ammo!", "#e74c3c")); return; }
                this.reloading = true; this.reloadEndTime = Date.now() + stats.reloadTime;
                particles.push(new TextParticle(this.x, this.y - 40, "Reloading...", "#fff"));
            }

            finishReload() {
                this.reloading = false;
                const w = this.getActiveWeapon(); const stats = WEAPONS[w.type];
                const needed = stats.capacity - w.mag;
                const available = this.ammoBag[stats.ammoType];
                const amount = Math.min(needed, available);
                w.mag += amount; this.ammoBag[stats.ammoType] -= amount; updateUI();
            }

            takeDamage(amount) {
                let reducedAmount = amount;
                if (this.vestLevel === 1) reducedAmount *= 0.85; 
                else if (this.vestLevel === 2) reducedAmount *= 0.70; 
                else if (this.vestLevel === 3) reducedAmount *= 0.55; 
                
                this.hp -= reducedAmount;
                if(this.isHealing) this.cancelAction();
                particles.push(new TextParticle(this.x, this.y, `-${Math.floor(reducedAmount)}`, "#e74c3c"));
                for(let i=0; i<3; i++) particles.push(new Particle(this.x, this.y, '#e74c3c'));
                updateUI();

                if (this.hp <= 0 && !this.dead) { 
                    this.dead = true; 
                    endGame(false); 
                }
            }

            draw() {
                // If dead, show skull and skip regular draw
                if (this.dead) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.font = '40px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ðŸ’€', 0, 0);
                    ctx.restore();
                    return;
                }

                if (this.isRemote && !this.connected) return;

                let opacity = this.inBush ? 0.4 : 1.0;
                ctx.save(); ctx.translate(this.x, this.y); ctx.globalAlpha = opacity; ctx.rotate(this.angle);

                // Ghillie Logic: Draw same color as ground, no border
                if (this.isGhillie) {
                    ctx.fillStyle = COLORS.ghillie;
                    // No stroke for perfect camo
                    ctx.beginPath();
                    // Irregular shape for ghillie
                    for(let i=0; i<7; i++) {
                        let a = (i/7)*Math.PI*2;
                        let r = 32 + Math.sin(Date.now()/200 + i)*2; 
                        ctx.arc(Math.cos(a)*r*0.6, Math.sin(a)*r*0.6, r, 0, Math.PI*2);
                    }
                    ctx.fill();
                } else {
                    let packColor = '#665c3b';
                    if(this.backpackLevel===1) packColor = COLORS.pack1; if(this.backpackLevel===2) packColor = COLORS.pack2; if(this.backpackLevel===3) packColor = COLORS.pack3;
                    ctx.fillStyle = packColor; ctx.fillRect(-20, -15, 12, 30);

                    ctx.fillStyle = COLORS.playerHand;
                    let rightOffset = 0;
                    if (Date.now() - this.lastShotTime < 100 && this.getActiveWeapon().type === 'fist') rightOffset = 15;
                    ctx.beginPath(); ctx.arc(20 + rightOffset, 20, 10, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                    ctx.beginPath(); ctx.arc(20, -20, 10, 0, Math.PI*2); ctx.fill(); ctx.stroke();

                    if (this.getActiveWeapon().type !== 'fist') { ctx.fillStyle = '#333'; ctx.fillRect(10, -5, 45, 10); }

                    let bodyColor = this.isRemote ? COLORS.opponentBody : COLORS.playerBody;
                    if(this.vestLevel === 1) bodyColor = COLORS.vest1; if(this.vestLevel === 2) bodyColor = COLORS.vest2; if(this.vestLevel === 3) bodyColor = COLORS.vest3;
                    
                    ctx.fillStyle = bodyColor; ctx.beginPath(); ctx.arc(0,0, this.radius, 0, Math.PI*2); ctx.fill();
                    ctx.lineWidth = 3; ctx.strokeStyle = '#000'; ctx.stroke();
                    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.beginPath(); ctx.arc(0,0, 15, 0, Math.PI*2); ctx.fill();
                }
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, angle, owner, stats) {
                this.x = x; this.y = y; this.dx = Math.cos(angle) * stats.speed; this.dy = Math.sin(angle) * stats.speed;
                this.owner = owner; this.damage = stats.damage; this.life = stats.range / stats.speed; this.radius = 5; // Bigger
                this.color = stats.color;
            }
            update() { this.x += this.dx; this.y += this.dy; this.life--; }
            draw() {
                if(this.color==='transparent') return;
                ctx.fillStyle = this.color; 
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
                // High visibility border
                ctx.strokeStyle = 'black'; ctx.lineWidth = 2; ctx.stroke();
            }
        }

        class Obstacle extends Entity {
            constructor(x, y, type) {
                let r = 50;
                if (type === 'tree') r = 60; if (type === 'crate') r = 40; if (type === 'bush') r = 70;
                if (type === 'chest' || type === 'airdrop') r = 50;
                super(x, y, r);
                this.type = type; this.hp = 9999;
                if(type === 'crate') this.hp = 40; if(type === 'stone') this.hp = 80;
                if(type === 'chest') this.hp = 200; if(type === 'airdrop') this.hp = 100;
                
                // Determine loot deterministically at spawn time
                this.lootItem = null;
                if (type === 'crate') this.lootItem = determineLootItem(x, y);
                else if (type === 'chest') this.lootItem = 'm249';
                else if (type === 'airdrop') this.lootItem = determineLootItem(x, y, false, true);
            }
            takeDamage(amount) {
                if (this.type === 'bush' || this.type === 'tree') return; 
                this.hp -= amount; particles.push(new Particle(this.x, this.y, '#8e44ad'));
                if (this.hp <= 0 && !this.dead) {
                    this.dead = true;
                    if(this.lootItem) {
                        loot.push(new Loot(this.x, this.y, this.lootItem));
                        if(this.type === 'chest') {
                            loot.push(new Loot(this.x+30, this.y, 'vest3'));
                            loot.push(new Loot(this.x-30, this.y, 'pack3'));
                        }
                        if(this.type === 'airdrop') {
                            loot.push(new Loot(this.x+30, this.y, 'ghillie'));
                            loot.push(new Loot(this.x-30, this.y, 'scope8x'));
                        }
                    }
                    else if(this.type === 'stone') { if(seededRandom()>0.5) spawnAmmoLoot(this.x, this.y); }
                    
                    for(let i=0; i<6; i++) particles.push(new Particle(this.x, this.y, '#6c3483'));
                }
            }
            draw() {
                if(this.dead) return;
                ctx.save(); ctx.translate(this.x, this.y);
                if (this.type === 'tree') {
                    ctx.fillStyle = '#27ae60'; ctx.beginPath(); ctx.arc(0,0,this.radius,0,Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#1e8449'; ctx.lineWidth = 4; ctx.stroke();
                    ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.arc(-15,-15,20,0,Math.PI*2); ctx.fill();
                } else if (this.type === 'stone') {
                    ctx.fillStyle = '#95a5a6'; ctx.beginPath(); ctx.arc(0,0,this.radius,0,Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#7f8c8d'; ctx.stroke();
                    if(this.hp < 80) { ctx.beginPath(); ctx.moveTo(-10, -10); ctx.lineTo(10, 10); ctx.stroke(); }
                } else if (this.type === 'crate' || this.type === 'airdrop') {
                    ctx.fillStyle = this.type==='airdrop' ? COLORS.airdrop : COLORS.crate;
                    ctx.fillRect(-this.radius,-this.radius,this.radius*2,this.radius*2);
                    ctx.strokeStyle = '#5b2c6f'; ctx.lineWidth = 4; ctx.strokeRect(-this.radius,-this.radius,this.radius*2,this.radius*2);
                    ctx.beginPath(); ctx.moveTo(-this.radius,-this.radius); ctx.lineTo(this.radius,this.radius);
                    ctx.moveTo(this.radius,-this.radius); ctx.lineTo(-this.radius,this.radius); ctx.stroke();
                } else if (this.type === 'chest') {
                    ctx.fillStyle = COLORS.chest; ctx.fillRect(-this.radius, -this.radius, this.radius*2, this.radius*2);
                    ctx.strokeStyle = '#d35400'; ctx.lineWidth = 5; ctx.strokeRect(-this.radius, -this.radius, this.radius*2, this.radius*2);
                    ctx.fillStyle = '#d35400'; ctx.font='bold 20px Arial'; ctx.textAlign='center'; ctx.fillText("KING",0,8);
                } else if (this.type === 'bush') {
                    ctx.globalAlpha = 0.9; ctx.fillStyle = COLORS.bush; ctx.beginPath();
                    for(let i=0; i<7; i++) {
                        let a = (i/7)*Math.PI*2; let r = this.radius * (0.8 + seededRandom()*0.2);
                        ctx.arc(Math.cos(a)*20, Math.sin(a)*20, r/1.5, 0, Math.PI*2);
                    } ctx.fill();
                }
                ctx.restore();
            }
        }

        // ... Loot, Wall, Roof, Particle classes same as before ...
        
        class Loot extends Entity {
            constructor(x, y, type) {
                super(x, y, 20); 
                this.type = type; 
                this.id = Math.floor(x) + "_" + Math.floor(y) + "_" + type;
                this.bob = seededRandom()*Math.PI;
            }
            draw() {
                if(this.dead) return;
                let offset = Math.sin(Date.now()/200 + this.bob)*5;
                ctx.save(); ctx.translate(this.x, this.y + offset);
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.arc(0,0,25,0,Math.PI*2); ctx.fill();
                
                let label = "?"; let color = "#ccc"; let sub = "";
                if(this.type === 'medkit') { label = "+"; color = "#e74c3c"; sub = "MED"; }
                else if (this.type.startsWith('ammo_')) {
                    let at = this.type.replace('ammo_', '');
                    label = "A"; color = AMMO_TYPES[at]; sub = at;
                } else if(this.type.startsWith('scope')) { 
                    label = this.type.replace('scope',''); color = "#3498db"; sub = "SCOPE";
                } else if(this.type.startsWith('vest')) {
                    label = "V"; color = "#95a5a6"; sub = this.type.replace('vest','Lvl ');
                } else if(this.type.startsWith('pack')) {
                    label = "B"; color = "#3498db"; sub = this.type.replace('pack','Lvl ');
                } else if(this.type === 'ghillie') {
                    label = "G"; color = "#78ab46"; sub = "SUIT";
                } else if(WEAPONS[this.type]) { 
                    label = WEAPONS[this.type].name.substring(0,3); color = WEAPONS[this.type].color; sub = WEAPONS[this.type].name;
                }
                
                ctx.fillStyle = color; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(label, 0, 0);
                ctx.fillStyle = 'white'; ctx.font = '10px Arial'; ctx.fillText(sub, 0, 20);
                ctx.restore();
            }
        }

        // ... Wall, Roof, Particle ...
        class Wall {
            constructor(x, y, w, h) { this.x=x; this.y=y; this.w=w; this.h=h; }
            draw() {
                ctx.fillStyle = COLORS.wall; ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.strokeStyle = '#1a252f'; ctx.lineWidth = 4; ctx.strokeRect(this.x, this.y, this.w, this.h);
            }
        }

        class Roof {
            constructor(x, y, w, h) { this.x=x; this.y=y; this.w=w; this.h=h; this.opacity = 1.0; }
            update() {
                if (!player) return;
                if (player.x > this.x && player.x < this.x+this.w && player.y > this.y && player.y < this.y+this.h) {
                    this.opacity = Math.max(0.1, this.opacity - 0.1);
                } else {
                    this.opacity = Math.min(1.0, this.opacity + 0.1);
                }
            }
            draw() {
                if (this.opacity <= 0.15) return;
                ctx.save(); ctx.globalAlpha = this.opacity;
                ctx.fillStyle = COLORS.roof; ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x+this.w, this.y+this.h);
                ctx.moveTo(this.x+this.w, this.y); ctx.lineTo(this.x, this.y+this.h); ctx.stroke();
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x=x; this.y=y; this.color=color;
                let a=Math.random()*Math.PI*2; let s=Math.random()*3+1;
                this.dx=Math.cos(a)*s; this.dy=Math.sin(a)*s; this.life=1.0;
            }
            update() { this.x+=this.dx; this.y+=this.dy; this.life-=0.05; }
            draw() { ctx.globalAlpha=this.life; ctx.fillStyle=this.color; ctx.fillRect(this.x,this.y,5,5); ctx.globalAlpha=1; }
        }
        class TextParticle extends Particle {
            constructor(x, y, text, color) { super(x,y,color); this.text=text; this.dx=0; this.dy=-1; this.life=1.5; }
            update() { this.y+=this.dy; this.life-=0.02; }
            draw() { ctx.globalAlpha=this.life; ctx.fillStyle=this.color; ctx.font='bold 20px Arial'; ctx.fillText(this.text,this.x,this.y); ctx.globalAlpha=1; }
        }

        // ... InitGame: spawn more crates (450) ...
        function initGame(seed) {
            mapSeed = seed || 12345;
            bullets = []; obstacles = []; loot = []; particles = []; walls = []; roofs = []; floors = [];
            
            createBuilding(MAP_SIZE/2 - 400, MAP_SIZE/2 - 300, 800, 600, 'club');

            for(let i=0; i<15; i++) {
                let bx = seededRandom() * (MAP_SIZE - 600) + 300;
                let by = seededRandom() * (MAP_SIZE - 600) + 300;
                if (Math.hypot(bx - MAP_SIZE/2, by - MAP_SIZE/2) < 800) continue;
                createBuilding(bx, by, 300, 300, 'house');
            }

            // Increased crate count to 450
            for(let i=0; i<450; i++) {
                let ox = seededRandom() * (MAP_SIZE - 200) + 100;
                let oy = seededRandom() * (MAP_SIZE - 200) + 100;
                let inside = false;
                for(let f of floors) { if (ox > f.x && ox < f.x+f.w && oy > f.y && oy < f.y+f.h) inside = true; }
                if (!inside) {
                    let rand = seededRandom();
                    let type = 'tree';
                    if (rand < 0.25) type = 'bush'; else if (rand < 0.5) type = 'stone'; else if (rand < 0.6) type = 'crate';
                    obstacles.push(new Obstacle(ox, oy, type));
                }
            }

            if (isHost) {
                player = new Player(MAP_SIZE/2 - 300, MAP_SIZE/2);
                opponent = new Player(MAP_SIZE/2 + 300, MAP_SIZE/2, true);
            } else {
                player = new Player(MAP_SIZE/2 + 300, MAP_SIZE/2);
                opponent = new Player(MAP_SIZE/2 - 300, MAP_SIZE/2, true);
            }

            zone = { x: MAP_SIZE/2, y: MAP_SIZE/2, radius: MAP_SIZE, phaseIdx: 0, damage: 0, damageTick: 0 };
            gameTime = 0;
            airdropDropped = false;
            updateUI();
        }

        // ... Helper: spawnAmmoLoot, circleRectCollide (Standard) ...
        function spawnAmmoLoot(x, y) {
             let types = ['ammo_556mm', 'ammo_762mm', 'ammo_9mm', 'ammo_12gauge'];
             let r = types[Math.floor(seededRandom() * types.length)];
             loot.push(new Loot(x, y, r));
        }
        function circleRectCollide(circle, rect) {
            let distX = Math.abs(circle.x - rect.x - rect.w/2);
            let distY = Math.abs(circle.y - rect.y - rect.h/2);
            if (distX > (rect.w/2 + circle.radius)) return false;
            if (distY > (rect.h/2 + circle.radius)) return false;
            if (distX <= (rect.w/2)) return true; 
            if (distY <= (rect.h/2)) return true;
            let dx = distX - rect.w/2; let dy = distY - rect.h/2;
            return (dx*dx + dy*dy <= (circle.radius*circle.radius));
        }

        // ... End of Script ...
    </script>
</body>
</html>
